<!doctype html>
<html lang="zh-TW" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ê≥°Ê≥°Ê∂àÈô§ÈÅäÊà≤</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="/_sdk/data_sdk.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      box-sizing: border-box;
    }
    
    .bubble {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, opacity 0.3s;
      border: 3px solid rgba(255, 255, 255, 0.3);
      box-shadow: inset -5px -5px 10px rgba(0, 0, 0, 0.1),
                  inset 5px 5px 10px rgba(255, 255, 255, 0.3),
                  0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    @media (max-width: 640px) {
      .bubble {
        width: 40px;
        height: 40px;
      }
    }
    
    .bubble:hover {
      transform: scale(1.1);
    }
    
    .bubble.selected {
      border-color: #ffffff;
      border-width: 4px;
      animation: pulse 0.5s ease-in-out infinite;
    }
    
    .bubble.removing {
      animation: pop 0.3s ease-out forwards;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }
    
    @keyframes pop {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.7; }
      100% { transform: scale(0); opacity: 0; }
    }
    
    @keyframes fall {
      from { transform: translateY(-100px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .bubble.falling {
      animation: fall 0.4s ease-out;
    }
    
    .score-pop {
      position: fixed;
      font-size: 2rem;
      font-weight: bold;
      pointer-events: none;
      animation: scoreFloat 1s ease-out forwards;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes scoreFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-100px) scale(1.5); }
    }
    
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: white;
      border-radius: 1rem;
      padding: 2rem;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <style>@view-transition { navigation: auto; }</style>
 </head>
 <body class="h-full">
  <div id="app" class="w-full h-full flex flex-col overflow-auto"></div>
  <script>
    const defaultConfig = {
      background_color: "#667eea",
      surface_color: "#ffffff",
      text_color: "#1a202c",
      primary_action_color: "#48bb78",
      secondary_action_color: "#4299e1",
      font_family: "sans-serif",
      font_size: 16,
      game_title: "üéà Ê≥°Ê≥°Ê∂àÈô§",
      score_label: "ÂàÜÊï∏",
      moves_label: "Ê≠•Êï∏",
      restart_button: "ÈáçÊñ∞ÈñãÂßã",
      reset_button: "ÈáçÁΩÆÂàÜÊï∏",
      high_score_label: "ÊúÄÈ´òÂàÜ"
    };

    let gameState = {
      grid: [],
      score: 0,
      moves: 0,
      selectedBubbles: [],
      isLoading: false
    };

    let savedData = [];
    let currentGameRecord = null;

    const GRID_SIZE = 8;
    const COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];

    const dataHandler = {
      onDataChanged(data) {
        savedData = data;
        render();
      }
    };

    async function initDataSDK() {
      if (window.dataSdk) {
        const result = await window.dataSdk.init(dataHandler);
        if (!result.isOk) {
          console.error("Failed to initialize data SDK");
        }
      }
    }

    function getHighScore() {
      if (savedData.length === 0) return 0;
      return Math.max(...savedData.map(record => record.high_score || 0));
    }

    async function saveScore() {
      if (!window.dataSdk) return;
      
      if (gameState.score === 0) return;

      gameState.isLoading = true;
      render();

      const highScore = getHighScore();
      
      if (gameState.score > highScore) {
        if (savedData.length >= 999) {
          showMessage("Â∑≤ÈÅîÂà∞ÊúÄÂ§ßÂÑ≤Â≠òÈôêÂà∂ (999 Á≠ÜË®òÈåÑ)");
          gameState.isLoading = false;
          render();
          return;
        }

        const result = await window.dataSdk.create({
          high_score: gameState.score,
          timestamp: new Date().toISOString()
        });

        if (!result.isOk) {
          showMessage("ÂÑ≤Â≠òÂàÜÊï∏ÊôÇÁôºÁîüÈåØË™§");
        }
      }

      gameState.isLoading = false;
      render();
    }

    async function resetHighScore() {
      if (!window.dataSdk || savedData.length === 0) return;

      gameState.isLoading = true;
      render();

      for (const record of savedData) {
        await window.dataSdk.delete(record);
      }

      gameState.isLoading = false;
      render();
    }

    function showMessage(message) {
      const messageEl = document.createElement('div');
      messageEl.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-white px-6 py-3 rounded-lg shadow-lg z-50';
      messageEl.style.color = window.elementSdk?.config?.text_color || defaultConfig.text_color;
      messageEl.textContent = message;
      document.body.appendChild(messageEl);
      
      setTimeout(() => {
        messageEl.style.transition = 'opacity 0.3s';
        messageEl.style.opacity = '0';
        setTimeout(() => messageEl.remove(), 300);
      }, 2000);
    }

    function initGrid() {
      gameState.grid = [];
      for (let i = 0; i < GRID_SIZE; i++) {
        gameState.grid[i] = [];
        for (let j = 0; j < GRID_SIZE; j++) {
          gameState.grid[i][j] = {
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            row: i,
            col: j
          };
        }
      }
      gameState.score = 0;
      gameState.moves = 0;
      gameState.selectedBubbles = [];
    }

    function findConnectedBubbles(row, col, color, visited = new Set()) {
      const key = `${row}-${col}`;
      
      if (visited.has(key)) return [];
      if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE) return [];
      if (!gameState.grid[row] || !gameState.grid[row][col]) return [];
      if (gameState.grid[row][col].color !== color) return [];
      
      visited.add(key);
      const connected = [{ row, col }];
      
      const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
      for (const [dr, dc] of directions) {
        connected.push(...findConnectedBubbles(row + dr, col + dc, color, visited));
      }
      
      return connected;
    }

    function handleBubbleClick(row, col) {
      if (gameState.isLoading) return;
      
      const bubble = gameState.grid[row][col];
      if (!bubble) return;
      
      const connected = findConnectedBubbles(row, col, bubble.color);
      
      if (connected.length >= 2) {
        gameState.selectedBubbles = connected;
        render();
        
        setTimeout(() => {
          removeBubbles(connected);
        }, 500);
      }
    }

    function removeBubbles(bubbles) {
      const points = bubbles.length * 10;
      gameState.score += points;
      gameState.moves++;
      
      const firstBubble = bubbles[0];
      const bubbleEl = document.querySelector(`[data-row="${firstBubble.row}"][data-col="${firstBubble.col}"]`);
      if (bubbleEl) {
        const rect = bubbleEl.getBoundingClientRect();
        showScorePop(points, rect.left + rect.width / 2, rect.top);
      }
      
      bubbles.forEach(({ row, col }) => {
        gameState.grid[row][col] = null;
      });
      
      gameState.selectedBubbles = [];
      
      applyGravity();
      saveScore();
      render();
    }

    function applyGravity() {
      for (let col = 0; col < GRID_SIZE; col++) {
        let emptyRow = GRID_SIZE - 1;
        
        for (let row = GRID_SIZE - 1; row >= 0; row--) {
          if (gameState.grid[row][col] !== null) {
            if (row !== emptyRow) {
              gameState.grid[emptyRow][col] = gameState.grid[row][col];
              gameState.grid[emptyRow][col].row = emptyRow;
              gameState.grid[row][col] = null;
            }
            emptyRow--;
          }
        }
        
        for (let row = emptyRow; row >= 0; row--) {
          gameState.grid[row][col] = {
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            row: row,
            col: col
          };
        }
      }
    }

    function showScorePop(points, x, y) {
      const scoreEl = document.createElement('div');
      scoreEl.className = 'score-pop';
      scoreEl.textContent = `+${points}`;
      scoreEl.style.left = `${x}px`;
      scoreEl.style.top = `${y}px`;
      scoreEl.style.color = window.elementSdk?.config?.primary_action_color || defaultConfig.primary_action_color;
      document.body.appendChild(scoreEl);
      
      setTimeout(() => scoreEl.remove(), 1000);
    }

    function restartGame() {
      initGrid();
      render();
    }

    function showResetModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-backdrop';
      modal.innerHTML = `
        <div class="modal-content">
          <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: ${window.elementSdk?.config?.text_color || defaultConfig.text_color};">Á¢∫Ë™çÈáçÁΩÆ</h2>
          <p style="margin-bottom: 1.5rem; color: ${window.elementSdk?.config?.text_color || defaultConfig.text_color};">Á¢∫ÂÆöË¶ÅÈáçÁΩÆÊúÄÈ´òÂàÜË®òÈåÑÂóéÔºüÊ≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©Âéü„ÄÇ</p>
          <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
            <button id="cancel-reset" style="padding: 0.5rem 1rem; border-radius: 0.5rem; background-color: ${window.elementSdk?.config?.surface_color || defaultConfig.surface_color}; color: ${window.elementSdk?.config?.text_color || defaultConfig.text_color}; border: 2px solid ${window.elementSdk?.config?.secondary_action_color || defaultConfig.secondary_action_color}; cursor: pointer;">ÂèñÊ∂à</button>
            <button id="confirm-reset" style="padding: 0.5rem 1rem; border-radius: 0.5rem; background-color: #ef4444; color: white; border: none; cursor: pointer;">Á¢∫Ë™çÈáçÁΩÆ</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      document.getElementById('cancel-reset').onclick = () => modal.remove();
      document.getElementById('confirm-reset').onclick = async () => {
        modal.remove();
        await resetHighScore();
      };
      
      modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
      };
    }

    function render() {
      const config = window.elementSdk?.config || defaultConfig;
      const app = document.getElementById('app');
      const highScore = getHighScore();
      
      app.style.backgroundColor = config.background_color;
      app.style.fontFamily = `${config.font_family}, sans-serif`;
      
      app.innerHTML = `
        <div style="max-width: 600px; margin: 0 auto; padding: 2rem;">
          <h1 style="font-size: 2.5rem; font-weight: bold; text-align: center; margin-bottom: 2rem; color: ${config.surface_color};">${config.game_title}</h1>
          
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 2rem;">
            <div style="background-color: ${config.surface_color}; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); text-align: center;">
              <div style="font-size: 0.875rem; color: ${config.text_color}; opacity: 0.7; margin-bottom: 0.5rem;">${config.score_label}</div>
              <div style="font-size: 2rem; font-weight: bold; color: ${config.primary_action_color};">${gameState.score}</div>
            </div>
            
            <div style="background-color: ${config.surface_color}; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); text-align: center;">
              <div style="font-size: 0.875rem; color: ${config.text_color}; opacity: 0.7; margin-bottom: 0.5rem;">${config.moves_label}</div>
              <div style="font-size: 2rem; font-weight: bold; color: ${config.secondary_action_color};">${gameState.moves}</div>
            </div>
            
            <div style="background-color: ${config.surface_color}; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); text-align: center;">
              <div style="font-size: 0.875rem; color: ${config.text_color}; opacity: 0.7; margin-bottom: 0.5rem;">${config.high_score_label}</div>
              <div style="font-size: 2rem; font-weight: bold; color: #f59e0b;">${highScore}</div>
            </div>
          </div>
          
          <div style="background-color: ${config.surface_color}; padding: 2rem; border-radius: 1rem; box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1); margin-bottom: 2rem;">
            <div style="display: grid; grid-template-columns: repeat(8, 50px); gap: 8px; justify-content: center;" id="game-grid"></div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: center;">
            <button id="restart-btn" style="padding: 1rem 2rem; font-size: 1rem; font-weight: 600; border-radius: 0.75rem; background-color: ${config.primary_action_color}; color: white; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); transition: transform 0.2s; ${gameState.isLoading ? 'opacity: 0.5; cursor: not-allowed;' : ''}" ${gameState.isLoading ? 'disabled' : ''}>${config.restart_button}</button>
            
            <button id="reset-btn" style="padding: 1rem 2rem; font-size: 1rem; font-weight: 600; border-radius: 0.75rem; background-color: ${config.secondary_action_color}; color: white; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); transition: transform 0.2s; ${gameState.isLoading || savedData.length === 0 ? 'opacity: 0.5; cursor: not-allowed;' : ''}" ${gameState.isLoading || savedData.length === 0 ? 'disabled' : ''}>${config.reset_button}</button>
          </div>
        </div>
      `;
      
      const gridEl = document.getElementById('game-grid');
      
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const bubble = gameState.grid[i][j];
          if (bubble) {
            const bubbleEl = document.createElement('div');
            bubbleEl.className = 'bubble';
            bubbleEl.style.backgroundColor = bubble.color;
            bubbleEl.setAttribute('data-row', i);
            bubbleEl.setAttribute('data-col', j);
            
            const isSelected = gameState.selectedBubbles.some(
              b => b.row === i && b.col === j
            );
            if (isSelected) {
              bubbleEl.classList.add('selected');
            }
            
            bubbleEl.onclick = () => handleBubbleClick(i, j);
            gridEl.appendChild(bubbleEl);
          }
        }
      }
      
      const restartBtn = document.getElementById('restart-btn');
      if (restartBtn && !gameState.isLoading) {
        restartBtn.onmouseenter = () => {
          restartBtn.style.transform = 'scale(1.05)';
        };
        restartBtn.onmouseleave = () => {
          restartBtn.style.transform = 'scale(1)';
        };
        restartBtn.onclick = restartGame;
      }
      
      const resetBtn = document.getElementById('reset-btn');
      if (resetBtn && !gameState.isLoading && savedData.length > 0) {
        resetBtn.onmouseenter = () => {
          resetBtn.style.transform = 'scale(1.05)';
        };
        resetBtn.onmouseleave = () => {
          resetBtn.style.transform = 'scale(1)';
        };
        resetBtn.onclick = showResetModal;
      }
    }

    async function onConfigChange(config) {
      render();
    }

    function mapToCapabilities(config) {
      return {
        recolorables: [
          {
            get: () => config.background_color || defaultConfig.background_color,
            set: (value) => {
              config.background_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ background_color: value });
              }
            }
          },
          {
            get: () => config.surface_color || defaultConfig.surface_color,
            set: (value) => {
              config.surface_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ surface_color: value });
              }
            }
          },
          {
            get: () => config.text_color || defaultConfig.text_color,
            set: (value) => {
              config.text_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ text_color: value });
              }
            }
          },
          {
            get: () => config.primary_action_color || defaultConfig.primary_action_color,
            set: (value) => {
              config.primary_action_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ primary_action_color: value });
              }
            }
          },
          {
            get: () => config.secondary_action_color || defaultConfig.secondary_action_color,
            set: (value) => {
              config.secondary_action_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ secondary_action_color: value });
              }
            }
          }
        ],
        borderables: [],
        fontEditable: {
          get: () => config.font_family || defaultConfig.font_family,
          set: (value) => {
            config.font_family = value;
            if (window.elementSdk) {
              window.elementSdk.setConfig({ font_family: value });
            }
          }
        },
        fontSizeable: {
          get: () => config.font_size || defaultConfig.font_size,
          set: (value) => {
            config.font_size = value;
            if (window.elementSdk) {
              window.elementSdk.setConfig({ font_size: value });
            }
          }
        }
      };
    }

    function mapToEditPanelValues(config) {
      return new Map([
        ["game_title", config.game_title || defaultConfig.game_title],
        ["score_label", config.score_label || defaultConfig.score_label],
        ["moves_label", config.moves_label || defaultConfig.moves_label],
        ["high_score_label", config.high_score_label || defaultConfig.high_score_label],
        ["restart_button", config.restart_button || defaultConfig.restart_button],
        ["reset_button", config.reset_button || defaultConfig.reset_button]
      ]);
    }

    async function init() {
      await initDataSDK();
      
      if (window.elementSdk) {
        window.elementSdk.init({
          defaultConfig,
          onConfigChange,
          mapToCapabilities,
          mapToEditPanelValues
        });
      }
      
      initGrid();
      render();
    }

    init();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9b45a3b7721ff1e0',t:'MTc2NjgwNTE4MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
